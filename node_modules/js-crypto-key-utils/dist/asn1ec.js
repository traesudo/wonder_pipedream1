"use strict";
/**
 * asn1ec.js
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toJWK = exports.fromJWK = void 0;
var asn1_js_1 = __importDefault(require("asn1.js"));
var params = __importStar(require("./params"));
var octenc_1 = require("./octenc");
/**
 * Convert JWK to parsed ASN.1 EC key object
 * @param {JsonWebKey} jwk - A key object in JWK format.
 * @param {PublicOrPrivate} type - 'public' or 'private'
 * @param {boolean} [compact=false] - *Only for EC public keys*, the compact form of public key is given as ASN.1 object if true.
 * @return {Object} - Parsed ASN.1 object.
 */
var fromJWK = function (jwk, type, compact) {
    if (compact === void 0) { compact = false; }
    var octetPublicKey = (0, octenc_1.fromJwk)(jwk, { outputFormat: 'binary', outputPublic: true, compact: compact });
    var publicKeyAlgorithmOid = params.publicKeyAlgorithms['EC'].oid;
    var publicKey = { unused: 0, data: Array.from(octetPublicKey) }; //Buffer.from(octkeyObj.publicKey)};
    var parameters = ECParameters.encode({ type: 'namedCurve', value: params.namedCurves[jwk.crv].oid }, 'der');
    var algorithm = { algorithm: publicKeyAlgorithmOid, parameters: parameters };
    var decoded = {};
    if (type === 'public') { // SPKI
        decoded.subjectPublicKey = publicKey;
        decoded.algorithm = algorithm;
    }
    else if (type === 'private') { // PKCS8
        var octetPrivateKey = (0, octenc_1.fromJwk)(jwk, { outputFormat: 'binary', outputPublic: false, compact: compact });
        decoded.version = 0; // no public key presents for v2 (0)
        decoded.privateKeyAlgorithm = algorithm;
        decoded.privateKey = ECPrivateKey.encode({
            version: 1,
            privateKey: Array.from(octetPrivateKey),
            parameters: parameters,
            publicKey: publicKey
        }, 'der');
    }
    return decoded;
};
exports.fromJWK = fromJWK;
/**
 * Convert parsed ASN.1 EC key object to JWK.
 * @param {Object} decoded - Parsed ASN.1 EC key object.
 * @param {PublicOrPrivate} type - 'public' or 'private'
 * @return {JsonWebKey} - Converted key objects in JWK format.
 * @throws {Error} - Throws if UnsupportedCurve.
 */
var toJWK = function (decoded, type) {
    if (type === 'public') { // SPKI
        decoded.algorithm.parameters = ECParameters.decode(decoded.algorithm.parameters, 'der'); // overwrite nested binary object as parsed object
        var octPubKey = new Uint8Array(decoded.subjectPublicKey.data); // convert oct key to jwk
        var namedCurves = params.getAlgorithmFromOid(decoded.algorithm.parameters.value, params.namedCurves);
        return (0, octenc_1.toJwk)(octPubKey, namedCurves[0], { outputPublic: true });
    }
    else { // type === 'private', PKCS8
        decoded.privateKeyAlgorithm.parameters = ECParameters.decode(decoded.privateKeyAlgorithm.parameters, 'der');
        // Work around for optional private key parameter field.
        try {
            decoded.privateKey = ECPrivateKey.decode(decoded.privateKey, 'der');
        }
        catch (e) {
            decoded.privateKey = ECPrivateKeyAlt.decode(decoded.privateKey, 'der');
        }
        var octPrivKey = new Uint8Array(decoded.privateKey.privateKey);
        var namedCurves = params.getAlgorithmFromOid(decoded.privateKeyAlgorithm.parameters.value, params.namedCurves);
        if (namedCurves.length < 1)
            throw new Error('UnsupportedCurve');
        return (0, octenc_1.toJwk)(octPrivKey, namedCurves[0], { outputPublic: false });
    }
};
exports.toJWK = toJWK;
/////////////////////////
/**
 * ECParameters specified in RFC 5480 {@link https://tools.ietf.org/html/rfc5480}.
 * @type {AsnObject}
 */
var ECParameters = asn1_js_1.default.define('ECParameters', function () {
    // @ts-ignore
    this.choice({
        // @ts-ignore
        namedCurve: this.objid()
    });
});
/**
 * ECPrivateKey specified in RFC 5915 {@link https://tools.ietf.org/html/rfc5915}.
 * @type {AsnObject}
 */
var ECPrivateKey = asn1_js_1.default.define('ECPrivateKey', function () {
    // @ts-ignore
    this.seq().obj(
    // @ts-ignore
    this.key('version').int(), 
    // @ts-ignore
    this.key('privateKey').octstr(), 
    // @ts-ignore
    this.key('parameters').explicit(0).optional().any(), // rfc suggested that this must be implemented
    // @ts-ignore
    this.key('publicKey').explicit(1).optional().bitstr() // rfc suggested that this must be implemented
    );
});
/**
 * ECPrivateKey Alternative for an work around...
 * @type {AsnObject}
 */
var ECPrivateKeyAlt = asn1_js_1.default.define('ECPrivateKey', function () {
    // @ts-ignore
    this.seq().obj(
    // @ts-ignore
    this.key('version').int(), 
    // @ts-ignore
    this.key('privateKey').octstr(), 
    // this.key('parameters').explicit(0).optional().any(), // rfc suggested that this must be implemented
    // @ts-ignore
    this.key('publicKey').explicit(1).optional().bitstr() // rfc suggested that this must be implemented
    );
});
//# sourceMappingURL=asn1ec.js.map